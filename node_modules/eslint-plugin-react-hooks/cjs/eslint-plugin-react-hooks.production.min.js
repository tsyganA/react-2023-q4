/*
 React
 eslint-plugin-react-hooks.production.min.js

 Copyright (c) Meta Platforms, Inc. and affiliates.

 This source code is licensed under the MIT license found in the
 LICENSE file in the root directory of this source tree.
*/
'use strict';function fa(a,d){if(a){if("string"===typeof a)return ia(a,d);var f=Object.prototype.toString.call(a).slice(8,-1);"Object"===f&&a.constructor&&(f=a.constructor.name);if("Map"===f||"Set"===f)return Array.from(a);if("Arguments"===f||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(f))return ia(a,d)}}function ia(a,d){if(null==d||d>a.length)d=a.length;for(var f=0,p=Array(d);f<d;f++)p[f]=a[f];return p}
function P(a,d){var f;if("undefined"===typeof Symbol||null==a[Symbol.iterator]){if(Array.isArray(a)||(f=fa(a))||d&&a&&"number"===typeof a.length){f&&(a=f);var p=0;d=function(){};return{s:d,n:function(){return p>=a.length?{done:!0}:{done:!1,value:a[p++]}},e:function(k){throw k;},f:d}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var t=!0,I=!1,r;return{s:function(){f=a[Symbol.iterator]()},
n:function(){var k=f.next();t=k.done;return k},e:function(k){I=!0;r=k},f:function(){try{t||null==f.return||f.return()}finally{if(I)throw r;}}}}function na(a){if("Identifier"===a.type)return a=a.name,"use"===a||/^use[A-Z0-9]/.test(a);if("MemberExpression"===a.type&&!a.computed&&na(a.property)){a=a.object;var d=/^[A-Z].*/;return"Identifier"===a.type&&d.test(a.name)}return!1}function oa(a){return"Identifier"===a.type&&/^[A-Z]/.test(a.name)}
function pa(a,d){return a.name===d||"MemberExpression"===a.type&&"React"===a.object.name&&a.property.name===d}function qa(a){return!!(a.parent&&a.parent.callee&&pa(a.parent.callee,"forwardRef"))}function ua(a){return!!(a.parent&&a.parent.callee&&pa(a.parent.callee,"memo"))}function va(a){for(;a;){var d=wa(a);if(d&&(oa(d)||na(d))||qa(a)||ua(a))return!0;a=a.parent}return!1}
function wa(a){if("FunctionDeclaration"===a.type||"FunctionExpression"===a.type&&a.id)return a.id;if("FunctionExpression"===a.type||"ArrowFunctionExpression"===a.type)return"VariableDeclarator"===a.parent.type&&a.parent.init===a?a.parent.id:"AssignmentExpression"===a.parent.type&&a.parent.right===a&&"="===a.parent.operator?a.parent.left:"Property"!==a.parent.type||a.parent.value!==a||a.parent.computed?"AssignmentPattern"!==a.parent.type||a.parent.right!==a||a.parent.computed?void 0:a.parent.left:
a.parent.key}
function xa(a){function d(){return{isUsed:!1,isSatisfiedRecursively:!1,isSubtreeUsed:!1,children:new Map}}function f(h,n){n=n.split(".");n=P(n);var C;try{for(n.s();!(C=n.n()).done;){var G=C.value,H=h.children.get(G);H||(H=d(),h.children.set(G,H));h=H}}catch(J){n.e(J)}finally{n.f()}return h}function p(h,n,C){n=n.split(".");n=P(n);var G;try{for(n.s();!(G=n.n()).done;){var H=h.children.get(G.value);if(!H)break;C(H);h=H}}catch(J){n.e(J)}finally{n.f()}}function t(h,n,C,G){h.children.forEach(function(H,J){var S=
G(J);H.isSatisfiedRecursively?H.isSubtreeUsed&&C.add(S):H.isUsed?n.add(S):t(H,n,C,function(Q){return S+"."+Q})})}var I=a.dependencies,r=a.declaredDependencies,k=a.stableDependencies,y=a.externalDependencies,M=a.isEffect,D=d();I.forEach(function(h,n){f(D,n).isUsed=!0;p(D,n,function(C){C.isSubtreeUsed=!0})});r.forEach(function(h){f(D,h.key).isSatisfiedRecursively=!0});k.forEach(function(h){f(D,h).isSatisfiedRecursively=!0});a=new Set;var R=new Set;t(D,a,R,function(h){return h});var m=[],q=new Set,x=
new Set;r.forEach(function(h){h=h.key;R.has(h)?-1===m.indexOf(h)?m.push(h):x.add(h):!M||h.endsWith(".current")||y.has(h)?q.add(h):-1===m.indexOf(h)&&m.push(h)});a.forEach(function(h){m.push(h)});return{suggestedDependencies:m,unnecessaryDependencies:q,duplicateDependencies:x,missingDependencies:a}}
function V(a){switch(a.type){case "ObjectExpression":return"object";case "ArrayExpression":return"array";case "ArrowFunctionExpression":case "FunctionExpression":return"function";case "ClassExpression":return"class";case "ConditionalExpression":if(null!=V(a.consequent)||null!=V(a.alternate))return"conditional";break;case "LogicalExpression":if(null!=V(a.left)||null!=V(a.right))return"logical expression";break;case "JSXFragment":return"JSX fragment";case "JSXElement":return"JSX element";case "AssignmentExpression":if(null!=
V(a.right))return"assignment expression";break;case "NewExpression":return"object construction";case "Literal":if(a.value instanceof RegExp)return"regular expression";break;case "TypeCastExpression":case "AsExpression":case "TSAsExpression":return V(a.expression)}return null}
function ya(a){var d=a.declaredDependenciesNode,f=a.componentScope,p=a.scope;return a.declaredDependencies.map(function(t){var I=t.key;t=f.variables.find(function(y){return y.name===I});if(null==t)return null;var r=t.defs[0];if(null==r)return null;if("Variable"===r.type&&"VariableDeclarator"===r.node.type&&"Identifier"===r.node.id.type&&null!=r.node.init){var k=V(r.node.init);if(null!=k)return[t,k]}return"FunctionName"===r.type&&"FunctionDeclaration"===r.node.type?[t,"function"]:"ClassName"===r.type&&
"ClassDeclaration"===r.node.type?[t,"class"]:null}).filter(Boolean).map(function(t){var I=t[0];t=t[1];var r=I.defs[0];a:{for(var k=!1,y=0;y<I.references.length;y++){var M=I.references[y];if(M.writeExpr)if(k){I=!0;break a}else{k=!0;continue}for(var D=M.from;D!==p&&null!=D;)D=D.upper;if(D!==p&&!za(d,M.identifier)){I=!0;break a}}I=!1}return{construction:r,depType:t,isUsedOutsideOfHook:I}})}
function Aa(a){return"MemberExpression"!==a.parent.type&&"OptionalMemberExpression"!==a.parent.type||a.parent.object!==a||"current"===a.parent.property.name||a.parent.computed||null!=a.parent.parent&&("CallExpression"===a.parent.parent.type||"OptionalCallExpression"===a.parent.parent.type)&&a.parent.parent.callee===a.parent?"MemberExpression"===a.type&&a.parent&&"AssignmentExpression"===a.parent.type&&a.parent.left===a?a.object:a:Aa(a.parent)}
function Ba(a,d,f){d&&(a.optional?d.has(f)||d.set(f,!0):d.set(f,!1))}
function Y(a,d){if("Identifier"===a.type||"JSXIdentifier"===a.type)return a=a.name,d&&d.set(a,!1),a;if("MemberExpression"!==a.type||a.computed){if("OptionalMemberExpression"!==a.type||a.computed){if("ChainExpression"!==a.type||a.computed)throw Error("Unsupported node type: "+a.type);a=a.expression;if("CallExpression"===a.type)throw Error("Unsupported node type: "+a.type);var f=Y(a.object,d),p=Y(a.property,null);f=f+"."+p;Ba(a,d,f);return f}f=Y(a.object,d);p=Y(a.property,null);f=f+"."+p;Ba(a,d,f);
return f}f=Y(a.object,d);p=Y(a.property,null);f=f+"."+p;Ba(a,d,f);return f}function Ca(a){return"MemberExpression"!==a.type||"Identifier"!==a.object.type||"React"!==a.object.name||"Identifier"!==a.property.type||a.computed?a:a.property}
function Fa(a,d){var f=Ca(a);if("Identifier"!==f.type)return-1;switch(f.name){case "useEffect":case "useLayoutEffect":case "useCallback":case "useMemo":return 0;case "useImperativeHandle":return 1;default:if(f===a&&d&&d.additionalHooks){try{var p=Y(f,null)}catch(t){if(/Unsupported node type/.test(t.message))return 0;throw t;}return d.additionalHooks.test(p)?0:-1}return-1}}
function Ga(a,d){for(var f=[a],p=null;f.length;){p=f.shift();if(("Identifier"===p.type||"JSXIdentifier"===p.type)&&p.type===d.type&&p.name===d.name&&p.range[0]===d.range[0]&&p.range[1]===d.range[1])return p;if(za(p,d)){a=0;for(var t=Object.entries(p);a<t.length;a++){var I=t[a],r=I[1];"parent"!==I[0]&&(Ha(r)?(r.parent=p,f.push(r)):Array.isArray(r)&&r.forEach(function(k){Ha(k)&&(k.parent=p,f.push(k))}))}}}return null}
function Ia(a){for(var d="",f=0;f<a.length;f++)d+=a[f],0===f&&2===a.length?d+=" and ":f===a.length-2&&2<a.length?d+=", and ":f<a.length-1&&(d+=", ");return d}function Ha(a){return"object"===typeof a&&null!==a&&!Array.isArray(a)&&"string"===typeof a.type}function za(a,d){return a.range[0]<=d.range[0]&&a.range[1]>=d.range[1]}exports.configs={recommended:{plugins:["react-hooks"],rules:{"react-hooks/rules-of-hooks":"error","react-hooks/exhaustive-deps":"warn"}}};
exports.rules={"rules-of-hooks":{meta:{type:"problem",docs:{description:"enforces the Rules of Hooks",recommended:!0,url:"https://reactjs.org/docs/hooks-rules.html"}},create:function(a){function d(k){k=P(k.references);try{for(k.s();!k.n().done;);}catch(y){k.e(y)}finally{k.f()}}var f=null,p=[],t=[],I=new WeakSet,r={};return r.onCodePathSegmentStart=function(k){return t.push(k)},r.onCodePathSegmentEnd=function(){return t.pop()},r.onCodePathStart=function(){return p.push(new Map)},r.onCodePathEnd=function(k,
y){function M(l,A){var z=M.cache,u=z.get(l.id);A=new Set(A);if(A.has(l.id)){z=[].concat(A);l=z.slice(z.indexOf(l.id)+1);l=P(l);var E;try{for(l.s();!(E=l.n()).done;)q.add(E.value)}catch(N){l.e(N)}finally{l.f()}return BigInt("0")}A.add(l.id);if(void 0!==u)return u;if(k.thrownSegments.includes(l))u=BigInt("0");else if(0===l.prevSegments.length)u=BigInt("1");else{u=BigInt("0");E=P(l.prevSegments);var B;try{for(E.s();!(B=E.n()).done;)u+=M(B.value,A)}catch(N){E.e(N)}finally{E.f()}}l.reachable&&u===BigInt("0")?
z.delete(l.id):z.set(l.id,u);return u}function D(l,A){var z=D.cache,u=z.get(l.id);A=new Set(A);if(A.has(l.id)){z=Array.from(A);l=z.slice(z.indexOf(l.id)+1);l=P(l);var E;try{for(l.s();!(E=l.n()).done;)q.add(E.value)}catch(N){l.e(N)}finally{l.f()}return BigInt("0")}A.add(l.id);if(void 0!==u)return u;if(k.thrownSegments.includes(l))u=BigInt("0");else if(0===l.nextSegments.length)u=BigInt("1");else{u=BigInt("0");E=P(l.nextSegments);var B;try{for(E.s();!(B=E.n()).done;)u+=D(B.value,A)}catch(N){E.e(N)}finally{E.f()}}z.set(l.id,
u);return u}function R(l){var A=R.cache,z=A.get(l.id);if(null===z)return Infinity;if(void 0!==z)return z;A.set(l.id,null);if(0===l.prevSegments.length)z=1;else{z=Infinity;var u=P(l.prevSegments),E;try{for(u.s();!(E=u.n()).done;){var B=R(E.value);B<z&&(z=B)}}catch(N){u.e(N)}finally{u.f()}z+=1}A.set(l.id,z);return z}var m=p.pop();if(0!==m.size){var q=new Set;M.cache=new Map;D.cache=new Map;R.cache=new Map;var x=D(k.initialSegment),h=wa(y),n=va(y),C=h?oa(h)||na(h):qa(y)||ua(y),G=Infinity,H=P(k.finalSegments),
J;try{for(H.s();!(J=H.n()).done;){var S=J.value;if(S.reachable){var Q=R(S);Q<G&&(G=Q)}}}catch(l){H.e(l)}finally{H.f()}m=P(m);var K;try{for(m.s();!(K=m.n()).done;){var ca=K.value,T=ca[0],ra=ca[1];if(T.reachable){var ja=0===T.nextSegments.length?G<=R(T):G<R(T),O=M(T)*D(T),ha=q.has(T.id),X=P(ra),Z;try{for(X.s();!(Z=X.n()).done;){var F=Z.value;ha&&!pa(F,"use")&&a.report({node:F,message:'React Hook "'+a.getSource(F)+'" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'});
if(C){if(y.async&&a.report({node:F,message:'React Hook "'+a.getSource(F)+'" cannot be called in an async function.'}),!ha&&O!==x&&!pa(F,"use")){var aa='React Hook "'+a.getSource(F)+'" is called conditionally. React Hooks must be called in the exact same order in every component render.'+(ja?" Did you accidentally call a React Hook after an early return?":"");a.report({node:F,message:aa})}}else if(y.parent&&("MethodDefinition"===y.parent.type||"ClassProperty"===y.parent.type)&&y.parent.value===y){var L=
'React Hook "'+a.getSource(F)+'" cannot be called in a class component. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:F,message:L})}else if(h){var U='React Hook "'+a.getSource(F)+'" is called in function "'+(a.getSource(h)+'" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word "use".');a.report({node:F,message:U})}else if("Program"===
y.type){var ka='React Hook "'+a.getSource(F)+'" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:F,message:ka})}else if(n&&!pa(F,"use")){var da='React Hook "'+a.getSource(F)+'" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';a.report({node:F,message:da})}}}catch(l){X.e(l)}finally{X.f()}}}}catch(l){m.e(l)}finally{m.f()}}},r.CallExpression=
function(k){if(na(k.callee)){var y=p[p.length-1],M=t[t.length-1],D=y.get(M);D||(D=[],y.set(M,D));D.push(k.callee)}"Identifier"===k.callee.type&&"useEffect"===k.callee.name&&0<k.arguments.length&&(f=k)},r.Identifier=function(k){null==f&&I.has(k)&&"CallExpression"!==k.parent.type&&a.report({node:k,message:"`"+a.getSource(k)+'` is a function created with React Hook "useEffectEvent", and can only be called from the same component. They cannot be assigned to variables or passed down.'})},r["CallExpression:exit"]=
function(k){k===f&&(f=null)},r.FunctionDeclaration=function(k){va(k)&&d(a.getScope())},r.ArrowFunctionExpression=function(k){va(k)&&d(a.getScope())},r}},"exhaustive-deps":{meta:{type:"suggestion",docs:{description:"verifies the list of dependencies for Hooks like useEffect and similar",recommended:!0,url:"https://github.com/facebook/react/issues/14920"},fixable:"code",hasSuggestions:!0,schema:[{type:"object",additionalProperties:!1,enableDangerousAutofixThisMayCauseInfiniteLoops:!1,properties:{additionalHooks:{type:"string"},
enableDangerousAutofixThisMayCauseInfiniteLoops:{type:"boolean"}}}]},create:function(a){function d(m){t&&Array.isArray(m.suggest)&&0<m.suggest.length&&(m.fix=m.suggest[0].fix);a.report(m)}function f(m,q){return function(x){if(q.has(x))return q.get(x);var h=m(x);q.set(x,h);return h}}function p(m,q,x,h,n){function C(b){var e=P(b.references),c;try{for(e.s();!(c=e.n()).done;){var g=c.value;if(g.resolved&&S.has(g.resolved.scope)){var w=Ga(m,g.identifier),v=Aa(w),ba=Y(v,ha),ea;if(ea=n&&"Identifier"===v.type&&
("MemberExpression"===v.parent.type||"OptionalMemberExpression"===v.parent.type)&&!v.parent.computed&&"Identifier"===v.parent.property.type&&"current"===v.parent.property.name){for(var W=g.from,la=!1;W.block!==m;)"function"===W.type&&(la=null!=W.block.parent&&"ReturnStatement"===W.block.parent.type),W=W.upper;ea=la}ea&&ja.set(ba,{reference:g,dependencyNode:v});if("TSTypeQuery"!==v.parent.type&&"TSTypeReference"!==v.parent.type){var ma=g.resolved.defs[0];if(null!=ma&&(null==ma.node||ma.node.init!==
m.parent)&&"TypeParameter"!==ma.type)if(O.has(ba))O.get(ba).references.push(g);else{var Da=g.resolved,Ja=T(Da)||ra(Da);O.set(ba,{isStable:Ja,references:[g]})}}}}}catch(sa){e.e(sa)}finally{e.f()}b=P(b.childScopes);var Ea;try{for(b.s();!(Ea=b.n()).done;)C(Ea.value)}catch(sa){b.e(sa)}finally{b.f()}}function G(b){b=b.split(".");for(var e="",c=0;c<b.length;c++){if(0!==c){var g=b.slice(0,c+1).join(".");g=!0===ha.get(g);e+=g?"?.":"."}e+=b[c]}return e}function H(b,e,c,g){return 0===b.size?null:(1<b.size?
"":e+" ")+c+" "+(1<b.size?"dependencies":"dependency")+": "+Ia(Array.from(b).sort().map(function(w){return"'"+G(w)+"'"}))+(". Either "+g+" "+(1<b.size?"them":"it")+" or remove the dependency array.")}n&&m.async&&d({node:m,message:"Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching"});
for(var J=r.acquire(m),S=new Set,Q=null,K=J.upper;K;){S.add(K);if("function"===K.type)break;K=K.upper}if(K){Q=K;var ca=Array.isArray,T=f(function(b){if(!ca(b.defs))return!1;var e=b.defs[0];if(null==e||"VariableDeclarator"!==e.node.type)return!1;var c=e.node.init;if(null==c)return!1;for(;"TSAsExpression"===c.type||"AsExpression"===c.type;)c=c.expression;var g=e.node.parent;if(null==g&&(Ga(Q.block,e.node.id),g=e.node.parent,null==g))return!1;if("const"===g.kind&&"Literal"===c.type&&("string"===typeof c.value||
"number"===typeof c.value||null===c.value))return!0;if("CallExpression"!==c.type)return!1;c=c.callee;"MemberExpression"!==c.type||"React"!==c.object.name||null==c.property||c.computed||(c=c.property);if("Identifier"!==c.type)return!1;e=e.node.id;c=c.name;if("useRef"===c&&"Identifier"===e.type)return!0;if("useState"===c||"useReducer"===c){if("ArrayPattern"===e.type&&2===e.elements.length&&ca(b.identifiers)){if(e.elements[1]===b.identifiers[0]){if("useState"===c)for(b=b.references,g=c=0;g<b.length;g++){b[g].isWrite()&&
c++;if(1<c)return!1;k.set(b[g].identifier,e.elements[0])}return!0}if(e.elements[0]===b.identifiers[0]&&"useState"===c)for(b=b.references,e=0;e<b.length;e++)y.add(b[e].identifier)}}else if("useTransition"===c&&"ArrayPattern"===e.type&&2===e.elements.length&&Array.isArray(b.identifiers)&&e.elements[1]===b.identifiers[0])return!0;return!1},M),ra=f(function(b){if(!ca(b.defs))return!1;b=b.defs[0];if(null==b||null==b.node||null==b.node.id)return!1;var e=b.node,c=Q.childScopes;b=null;var g;for(g=0;g<c.length;g++){var w=
c[g],v=w.block;if("FunctionDeclaration"===e.type&&v===e||"VariableDeclarator"===e.type&&v.parent===e){b=w;break}}if(null==b)return!1;for(g=0;g<b.through.length;g++)if(e=b.through[g],null!=e.resolved&&S.has(e.resolved.scope)&&!T(e.resolved))return!1;return!0},D),ja=new Map,O=new Map,ha=new Map;C(J);ja.forEach(function(b,e){var c=b.dependencyNode;b=b.reference.resolved.references;for(var g=!1,w=0;w<b.length;w++){var v=b[w].identifier.parent;if(null!=v&&"MemberExpression"===v.type&&!v.computed&&"Identifier"===
v.property.type&&"current"===v.property.name&&"AssignmentExpression"===v.parent.type&&v.parent.left===v){g=!0;break}}g||d({node:c.parent.property,message:"The ref value '"+e+".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy '"+(e+".current' to a variable inside the effect, and use that variable in the cleanup function.")})});var X=new Set,Z=new Set;O.forEach(function(b,e){var c=b.references;b.isStable&&Z.add(e);
c.forEach(function(g){g.writeExpr&&(g=g.writeExpr,X.has(e)||(X.add(e),d({node:g,message:"Assignments to the '"+e+"' variable from inside React Hook "+(a.getSource(x)+" will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside ")+(a.getSource(x)+".")})))})});if(!(0<X.size))if(q){var F=[],aa=new Set;K="TSAsExpression"===q.type&&"ArrayExpression"===q.expression.type;
"ArrayExpression"===q.type||K?(K?q.expression:q).elements.forEach(function(b){if(null!==b)if("SpreadElement"===b.type)d({node:b,message:"React Hook "+a.getSource(x)+" has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."});else{R.has(b)&&d({node:b,message:"Functions returned from `useEffectEvent` must not be included in the dependency array. Remove `"+(a.getSource(b)+"` from the list."),suggest:[{desc:"Remove the dependency `"+
a.getSource(b)+"`",fix:function(w){return w.removeRange(b.range)}}]});try{var e=Y(b,null)}catch(w){if(/Unsupported node type/.test(w.message)){"Literal"===b.type?O.has(b.value)?d({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. Did you mean to include "+(b.value+" in the array instead?")}):d({node:b,message:"The "+b.raw+" literal is not a valid dependency because it never changes. You can safely remove it."}):d({node:b,message:"React Hook "+a.getSource(x)+
" has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."});return}throw w;}for(var c=b;"MemberExpression"===c.type||"OptionalMemberExpression"===c.type||"ChainExpression"===c.type;)c=c.object||c.expression.object;var g=!Q.through.some(function(w){return w.identifier===c});F.push({key:e,node:b});g||aa.add(e)}}):d({node:q,message:"React Hook "+a.getSource(x)+" was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."});
var L=xa({dependencies:O,declaredDependencies:F,stableDependencies:Z,externalDependencies:aa,isEffect:n});K=L.unnecessaryDependencies;var U=L.missingDependencies,ka=L.duplicateDependencies,da=L.suggestedDependencies;if(0===ka.size+U.size+K.size)ya({declaredDependencies:F,declaredDependenciesNode:q,componentScope:Q,scope:J}).forEach(function(b){var e=b.construction,c=b.isUsedOutsideOfHook;b=b.depType;var g="function"===b?"useCallback":"useMemo",w="function"===b?"definition":"initialization",v="wrap the "+
w+" of '"+e.name.name+"' in its own "+g+"() Hook.";v="The '"+e.name.name+"' "+b+" "+("conditional"===b||"logical expression"===b?"could make":"makes")+" the dependencies of "+(h+" Hook (at line "+q.loc.start.line+") change on every render. ")+(c?"To fix this, "+v:"Move it inside the "+h+" callback. Alternatively, "+v);var ba;c&&"Variable"===e.type&&"function"===b&&(ba=[{desc:"Wrap the "+w+" of '"+e.name.name+"' in its own "+g+"() Hook.",fix:function(ea){var W="useMemo"===g?["useMemo(() => { return ",
"; })"]:["useCallback(",")"],la=W[1];return[ea.insertTextBefore(e.node.init,W[0]),ea.insertTextAfter(e.node.init,la)]}}]);d({node:e.node,message:v,suggest:ba})});else{!n&&0<U.size&&(da=xa({dependencies:O,declaredDependencies:[],stableDependencies:Z,externalDependencies:aa,isEffect:n}).suggestedDependencies);(function(){if(0===F.length)return!0;var b=F.map(function(c){return c.key}),e=b.slice().sort();return b.join(",")===e.join(",")})()&&da.sort();L="";if(0<K.size){var l=null;Array.from(K.keys()).forEach(function(b){null===
l&&b.endsWith(".current")&&(l=b)});if(null!==l)L=" Mutable values like '"+l+"' aren't valid dependencies because mutating them doesn't re-render the component.";else if(0<aa.size){var A=Array.from(aa)[0];J.set.has(A)||(L=" Outer scope values like '"+A+"' aren't valid dependencies because mutating them doesn't re-render the component.")}}if(!L&&U.has("props")){J=O.get("props");if(null==J)return;J=J.references;if(!Array.isArray(J))return;A=!0;for(var z=0;z<J.length;z++){var u=Ga(Q.block,J[z].identifier);
if(!u){A=!1;break}u=u.parent;if(null==u){A=!1;break}if("MemberExpression"!==u.type&&"OptionalMemberExpression"!==u.type){A=!1;break}}A&&(L=" However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the "+(h+" call and refer to those specific props inside ")+(a.getSource(x)+"."))}if(!L&&0<U.size){var E=null;U.forEach(function(b){if(!E){var e=Q.set.get(b),c=O.get(b);if(c.references[0].resolved===e&&(e=e.defs[0],null!=e&&null!=e.name&&
"Parameter"===e.type)){e=!1;for(var g,w=0;w<c.references.length;w++)if(g=c.references[w].identifier,null!=g&&null!=g.parent&&("CallExpression"===g.parent.type||"OptionalCallExpression"===g.parent.type)&&g.parent.callee===g){e=!0;break}e&&(E=b)}}});null!==E&&(L=" If '"+E+"' changes too often, find the parent component that defines it and wrap that definition in useCallback.")}if(!L&&0<U.size){var B=null;U.forEach(function(b){if(null===B)for(var e=O.get(b).references,c,g,w=0;w<e.length;w++){c=e[w].identifier;
for(g=c.parent;null!=g&&g!==Q.block;){if("CallExpression"===g.type){var v=k.get(g.callee);if(null!=v){v.name===b?B={missingDep:b,setter:g.callee.name,form:"updater"}:y.has(c)?B={missingDep:b,setter:g.callee.name,form:"reducer"}:(c=e[w].resolved,null!=c&&(c=c.defs[0],null!=c&&"Parameter"===c.type&&(B={missingDep:b,setter:g.callee.name,form:"inlineReducer"})));break}}g=g.parent}if(null!==B)break}});if(null!==B)switch(B.form){case "reducer":L=" You can also replace multiple useState variables with useReducer if '"+
(B.setter+"' needs the current value of '")+(B.missingDep+"'.");break;case "inlineReducer":L=" If '"+B.setter+"' needs the current value of '"+(B.missingDep+"', you can also switch to useReducer instead of useState and read '")+(B.missingDep+"' in the reducer.");break;case "updater":L=" You can also do a functional update '"+B.setter+"("+B.missingDep.slice(0,1)+" => ...)' if you only need '"+B.missingDep+"' in the '"+(B.setter+"' call.");break;default:throw Error("Unknown case.");}}d({node:q,message:"React Hook "+
a.getSource(x)+" has "+(H(U,"a","missing","include")||H(K,"an","unnecessary","exclude")||H(ka,"a","duplicate","omit"))+L,suggest:[{desc:"Update the dependencies array to be: ["+da.map(G).join(", ")+"]",fix:function(b){return b.replaceText(q,"["+da.map(G).join(", ")+"]")}}]})}}else{var N=null;O.forEach(function(b,e){N||b.references.forEach(function(c){if(!N&&k.has(c.identifier)){for(c=c.from;"function"!==c.type;)c=c.upper;c.block===m&&(N=e)}})});if(N){var ta=xa({dependencies:O,declaredDependencies:[],
stableDependencies:Z,externalDependencies:new Set,isEffect:!0}).suggestedDependencies;d({node:x,message:"React Hook "+h+" contains a call to '"+N+"'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass ["+ta.join(", ")+("] as a second argument to the "+h+" Hook."),suggest:[{desc:"Add dependencies array: ["+ta.join(", ")+"]",fix:function(b){return b.insertTextAfter(m,", ["+ta.join(", ")+"]")}}]})}}}}var t=a.options&&a.options[0]&&a.options[0].enableDangerousAutofixThisMayCauseInfiniteLoops||
!1,I={additionalHooks:a.options&&a.options[0]&&a.options[0].additionalHooks?new RegExp(a.options[0].additionalHooks):void 0,enableDangerousAutofixThisMayCauseInfiniteLoops:t},r=a.getSourceCode().scopeManager,k=new WeakMap,y=new WeakSet,M=new WeakMap,D=new WeakMap,R=new WeakSet;return{CallExpression:function(m){var q=Fa(m.callee,I);if(-1!==q){var x=m.arguments[q],h=m.callee,n=Ca(h).name;m=m.arguments[q+1];var C=!m||"Identifier"===m.type&&"undefined"===m.name?void 0:m;m=/Effect($|[^a-z])/g.test(n);
if(x)if(C||m){switch(x.type){case "FunctionExpression":case "ArrowFunctionExpression":p(x,C,h,n,m);return;case "TSAsExpression":p(x.expression,C,h,n,m);return;case "Identifier":if(!C||C.elements&&C.elements.some(function(G){return G&&"Identifier"===G.type&&G.name===x.name}))return;q=a.getScope().set.get(x.name);if(null==q||null==q.defs)return;q=q.defs[0];if(!q||!q.node)break;if("Variable"!==q.type&&"FunctionName"!==q.type)break;switch(q.node.type){case "FunctionDeclaration":p(q.node,C,h,n,m);return;
case "VariableDeclarator":if(q=q.node.init)switch(q.type){case "ArrowFunctionExpression":case "FunctionExpression":p(q,C,h,n,m);return}}break;default:d({node:h,message:"React Hook "+n+" received a function whose dependencies are unknown. Pass an inline function instead."});return}d({node:h,message:"React Hook "+n+" has a missing dependency: '"+x.name+"'. Either include it or remove the dependency array.",suggest:[{desc:"Update the dependencies array to be: ["+x.name+"]",fix:function(G){return G.replaceText(C,
"["+x.name+"]")}}]})}else"useMemo"!==n&&"useCallback"!==n||d({node:h,message:"React Hook "+n+" does nothing when called with only one argument. Did you forget to pass an array of dependencies?"});else d({node:h,message:"React Hook "+n+" requires an effect callback. Did you forget to pass a callback to the hook?"})}}}}}};

//# sourceMappingURL=eslint-plugin-react-hooks.production.min.js.map
